# 6.824 raft

[TOC] 



## detail

election timout

当 leader 失效时, 系统的不可用时间基本上就是 election timeout, 所以不能设的过大. 但是, 如果设置的过小,又会导致无法在超时之前完成选举.

### log replication

1. client request contains command
2. leader append it as a new entry
3. leader send AppendEntries in parallel
4. leader apply the entry to its state machine and return result to clien, when entry has been safely replicated

log entry contains {command, term} and also have a log index

<img src="/Users/yujiacheng/Library/Application Support/typora-user-images/image-20211225144013141.png" alt="image-20211225144013141" style="zoom: 33%;" />

A log is commited when it has been replicated on a majority of servers.

leader 维护一个 highest commited log index and include it into AppendEntries (including heartbeat), 相当于告诉 follower, 哪些 log 包含的命令可以被运用到状态机中.

<img src="/Users/yujiacheng/Library/Application Support/typora-user-images/image-20211225154727064.png" alt="image-20211225154727064" style="zoom:33%;" />

如果不同 log 中的两个 entry 有相同的 intex 和 term, 它们一定有相同的 command,且它们之前的 log entries 也都相同.

- 一个 leader 在一个 term 中, 对一个 index 只会产生一条 entry

- **consistency check**, leader 新增一条 entry, 当发送 AppendEntries RPC 会带上这条 entry 的上一条 entry 的 intex 和 term, follower 如果没有相同 term 和 index 的 log entry,就拒绝这个 RPC. 通过归纳法可以推出上条 feature.

leader 处理 inconsistency 的方式, forcing the folowers's logs to duplicate its own. 结合 safety, if a server don't have a log entry which have been commited, it will not win the election to be a leader. Thus, the leader always have all committed log entries. Thus, it is safy for a leader to overwrite a foollowe's logs.

如何找到最后一条 match 的 log entry? 一条一条往前比较, 或者优化为 term by term

leader matains a nextIndex for each follower, which is the index of the next lop entry the leader will send to that follower. 选上 leader 后, initial this variable to the index to the index just after the last one in its log. 也就是说,如果一条 log 的 index >= nextIndex, 那么就需要向 fowolloer 同步这条 log.



如何更新 commit index ?





### safty





## Hints

- rpc 时不要加锁，否则有可能发生死锁

  ![image-20211205105249811](/images/image-20211205105249811.png)

  

- rpc 不加锁时，期间状态可能发生变化，所以 rpc 结束后要先进行一些判断，才能将自己声明为 leader

### lab1 tips

- 选新 leader 要在5分钟之内完成，所以需要选择合适的 election timeout 和 heartbeat 间隔。

## Implementation

raft struct, raft 类

Make(), 创建 sever 实例

GetStat(), return current term and is leader

RequestVoteArgs(), RequestVoteReply(), rpc 参数

RequestVote,  handle vote requestion，

- 比较 candidate 的 term，比自己小就不给票

- 比较 candidate 的 last log 的 term 和 index，如果比自己小，就不给票

  

sendRequestVote, send vote rpc

Leader 选举成功后，像所有其他server发送heartbeat

候选者的 term <= 心跳包的 term，就认定发送者为 leader。候选者在请求投票时，要对比其他 server 的 term，只有比大多数 server up-to-date, 才有资格作为候选者, up-to-date 比较 term 和 log[] 长度

拥有全部 commited log 的 candidate 才能成为 leader -> commited log 包含在大部分的 server 中 -> candidate 需要拿到大部分选票, 就算其中有一半的 server 没有最新的 commited log，也至少有一个 server 是有 commited log 的，如果这个 candidate 没有最新的 commited log，那么他就拿不到多数选票。

server 们在交流的时候，发现 term 比别人小，就要更新 term



Start(), 2b 

ApplyMsg, others to leader in resonse to new entry



- 投票 rpc
- 心跳 rpc
- follower 周期检查 hb timeout 的 goroutine
- leader 周期发送 heartbeat 的 goroutine

send rpc 放在单独的 goroutine 中，并在其中处理 response

初始化，启动，timeout，选举，发送心跳



## lab2a 实现逻辑

make 初始化 raft 节点时，起一个心跳包超时检测的 goroutine，这样一段时间之后，就有一个节点变成候选者，开始选举。

确定三个关键时间：

- leader 心跳间隔时间
  - 遍历 peer 发心跳

- follower 心跳超时时间 election timeout
  - 转为候选者
  - 发起选举

- candidate 过期时间 election timeout
  - 发起下一轮选举


turn to leader, candidate, follower

startHeartbeat, startRequestVote

AppendEntries RPC, RequestVote RPC



requestVote

- all, 收到比自己大的 term 会转换成 follower
- candidate 收到同期竞选的人的心跳，也要转换成 follower
- follower 的 term 比候选者的大，就不给他投票。（等于也是可以投票的） 
  - follower 投票了才会更新 election timeout



## lab2b 实现逻辑

### guide

[guide](https://thesquareplanet.com/blog/students-guide-to-raft/#the-importance-of-details)

- heartbeat 也要和常规的 AppendEntries 一样进行 log 相关的检测, 因为一旦回复 AppendEntries success 意味着告诉 leader 这个 server 的 log 和 leader 的 prevLogIndex match(包括在此之前的 log). leader 会根据这个信息来决定,是否 commit 某个 log.
- 不能简单的把 follower 的 log 根据 AppendEntries 的 prevLogIndex 来截断并append AppendEntries 中的 entries. 仅当发生 conflict 时,才能这样做.

heartbeat

- 不同的 follower 收到的 args 不同
- 添加回调

sendAppendEntries



appendEntries



args

- 加上 commit index, 收到之后取 min(leader, 当前有的log)

reply



candidate 选上 leader 后 reset timer 能否保证立即被 select?



![image-20220109170116160](/Users/yujiacheng/Library/Application Support/typora-user-images/image-20220109170116160.png)

![image-20220109182838354](/Users/yujiacheng/Library/Application Support/typora-user-images/image-20220109182838354.png)

issue: leader 分区

rf 0 重新加入后,应该被 rf2转成 follower 然后拷贝日志

问题: rf0 根本收不到 AppendEntries 



issue:

![image-20220109191824727](/Users/yujiacheng/Library/Application Support/typora-user-images/image-20220109191824727.png)

![image-20220109191926745](/Users/yujiacheng/Library/Application Support/typora-user-images/image-20220109191926745.png)

rf2 的 2 号日志和 rf0 的 2 号日志都被 commit 了却发生了不一致.





1. 0 当选 leader, log [nil, 101]

   ![image-20220109195527651](/Users/yujiacheng/Library/Application Support/typora-user-images/image-20220109195527651.png)

   [nil, 101] commitIndex:1

   ![image-20220109195708846](/Users/yujiacheng/Library/Application Support/typora-user-images/image-20220109195708846.png)

   ![image-20220109195729639](/Users/yujiacheng/Library/Application Support/typora-user-images/image-20220109195729639.png)

   index1 apply 没毛病

2. rf0 leader 开始发生网络分区, 且上层服务再次期间调用 start()

   ![image-20220109200120066](/Users/yujiacheng/Library/Application Support/typora-user-images/image-20220109200120066.png)

3. rf1 rf2 同时 election timeout 

   ![image-20220109200421562](/Users/yujiacheng/Library/Application Support/typora-user-images/image-20220109200421562.png)

4. rf1 election timeout

   ![image-20220109200605813](/Users/yujiacheng/Library/Application Support/typora-user-images/image-20220109200605813.png)

   1. rf1 选上leader

   2. 上层服务调用 start() 增加 rf1 log, index:2 command:103

   3. rf2 复制 2 号日志成功

   4. ![image-20220109202025754](/Users/yujiacheng/Library/Application Support/typora-user-images/image-20220109202025754.png)

      rf2 突然又收到了 rf 0 的消息

      a. rf0 收到 rf2 的回复,因为 rf2 的 term = 3 而 rf0 的 term = 1, 所以 rf0 转为 follower

      b. 这里 rf0 转为 follower 后,不应该继续处理心跳消息

## Bug

![image-20220109203835984](/Users/yujiacheng/Library/Application Support/typora-user-images/image-20220109203835984.png)

## issue

2022/01/11 23:02:07.790603 initial rf[0]
2022/01/11 23:02:07.791001 initial rf[1]
2022/01/11 23:02:07.791157 initial rf[2]
Test (2B): concurrent Start()s ...
2022/01/11 23:02:08.016031 rf[1] election timeout start election
2022/01/11 23:02:08.016296 rf[1] term:1 role:2, 	sendRequestVote,	To rf[0] args:{Term:1 CandidateId:1 LastLogIndex:0 LastLogTerm:0}
2022/01/11 23:02:08.016392 rf[1] term:1 role:2, 	sendRequestVote,	To rf[2] args:{Term:1 CandidateId:1 LastLogIndex:0 LastLogTerm:0}
2022/01/11 23:02:08.017010 rf[2] term:0 role:1 Handle RequestVote, sendRf[1] term:1, term > turn to follower
2022/01/11 23:02:08.017122 rf[2] term:1 role:1 Handle RequestVote, sendRf[1] term:1, follower vote
2022/01/11 23:02:08.017352 rf[0] term:0 role:1 Handle RequestVote, sendRf[1] term:1, term > turn to follower
2022/01/11 23:02:08.017472 rf[0] term:1 role:1 Handle RequestVote, sendRf[1] term:1, follower vote
2022/01/11 23:02:08.017594 rf[1] term:1 role:2,	handle sendRequestVote reply,	From rf[2],	args:&{Term:1 CandidateId:1 LastLogIndex:0 LastLogTerm:0}	reply:&{Term:1 VoteGranted:true}
2022/01/11 23:02:08.017651 rf[1] term:1 role:2,	handle sendRequestVote reply, Vote success, turn to leader, vote get:2 
2022/01/11 23:02:08.118024 rf[1] start heartbeat. log:[{Term:0 Command:<nil>}]
2022/01/11 23:02:08.118105 rf[1] heartbeat all send.
2022/01/11 23:02:08.118630 rf[2] term:1 role:1,	handle AppendEntries term == follower start handle,	From rf[1] term:1
2022/01/11 23:02:08.118711 rf[2] term:1 role:1 follower handle AppendEntries append success, args:&{Term:1 LeaderId:1 PrevLogIndex:0 PrevLogTerm:0 Entries:[] LeaderCommit:0}, log:[{Term:0 Command:<nil>}]
2022/01/11 23:02:08.118956 rf[1] term:1 role:3 FINISH handle AppendEntries response success from rf[2] matchIndex:[0 0 0]
2022/01/11 23:02:08.119229 rf[0] term:1 role:1,	handle AppendEntries term == follower start handle,	From rf[1] term:1
2022/01/11 23:02:08.119289 rf[0] term:1 role:1 follower handle AppendEntries append success, args:&{Term:1 LeaderId:1 PrevLogIndex:0 PrevLogTerm:0 Entries:[] LeaderCommit:0}, log:[{Term:0 Command:<nil>}]
2022/01/11 23:02:08.119464 rf[1] term:1 role:3 FINISH handle AppendEntries response success from rf[0] matchIndex:[0 0 0]
2022/01/11 23:02:08.218707 rf[1] start heartbeat. log:[{Term:0 Command:<nil>}]
2022/01/11 23:02:08.218892 rf[1] heartbeat all send.
2022/01/11 23:02:08.219471 rf[2] term:1 role:1,	handle AppendEntries term == follower start handle,	From rf[1] term:1
2022/01/11 23:02:08.219579 rf[2] term:1 role:1 follower handle AppendEntries append success, args:&{Term:1 LeaderId:1 PrevLogIndex:0 PrevLogTerm:0 Entries:[] LeaderCommit:0}, log:[{Term:0 Command:<nil>}]
2022/01/11 23:02:08.220379 rf[0] term:1 role:1,	handle AppendEntries term == follower start handle,	From rf[1] term:1
2022/01/11 23:02:08.220475 rf[0] term:1 role:1 follower handle AppendEntries append success, args:&{Term:1 LeaderId:1 PrevLogIndex:0 PrevLogTerm:0 Entries:[] LeaderCommit:0}, log:[{Term:0 Command:<nil>}]
2022/01/11 23:02:08.220691 rf[1] term:1 role:3 FINISH handle AppendEntries response success from rf[0] matchIndex:[0 0 0]
2022/01/11 23:02:08.273155 rf[1] term:1 role:3 FINISH handle AppendEntries response success from rf[2] matchIndex:[0 0 0]
2022/01/11 23:02:08.319860 rf[1] start heartbeat. log:[{Term:0 Command:<nil>}]
2022/01/11 23:02:08.319953 rf[1] heartbeat all send.
2022/01/11 23:02:08.469286 rf[0] term:1 role:1,	handle AppendEntries term == follower start handle,	From rf[1] term:1
2022/01/11 23:02:08.469400 rf[0] term:1 role:1 follower handle AppendEntries append success, args:&{Term:1 LeaderId:1 PrevLogIndex:0 PrevLogTerm:0 Entries:[] LeaderCommit:0}, log:[{Term:0 Command:<nil>}]
2022/01/11 23:02:08.469485 rf[2] term:1 role:1,	handle AppendEntries term == follower start handle,	From rf[1] term:1
2022/01/11 23:02:08.469536 rf[2] term:1 role:1 follower handle AppendEntries append success, args:&{Term:1 LeaderId:1 PrevLogIndex:0 PrevLogTerm:0 Entries:[] LeaderCommit:0}, log:[{Term:0 Command:<nil>}]
2022/01/11 23:02:08.469858 rf[1] term:1 role:3 FINISH handle AppendEntries response success from rf[0] matchIndex:[0 0 0]
2022/01/11 23:02:08.469966 rf[1] start heartbeat. log:[{Term:0 Command:<nil>} {Term:1 Command:1}]
2022/01/11 23:02:08.470020 rf[1] heartbeat all send.
2022/01/11 23:02:08.470157 rf[1] start heartbeat. log:[{Term:0 Command:<nil>} {Term:1 Command:1} {Term:1 Command:104}]
2022/01/11 23:02:08.470206 rf[1] heartbeat all send.
2022/01/11 23:02:08.470316 rf[1] start heartbeat. log:[{Term:0 Command:<nil>} {Term:1 Command:1} {Term:1 Command:104} {Term:1 Command:100}]
2022/01/11 23:02:08.470374 rf[1] heartbeat all send.
2022/01/11 23:02:08.470462 rf[1] term:1 role:3 FINISH handle AppendEntries response success from rf[2] matchIndex:[0 6 0]
2022/01/11 23:02:08.470566 rf[1] start heartbeat. log:[{Term:0 Command:<nil>} {Term:1 Command:1} {Term:1 Command:104} {Term:1 Command:100} {Term:1 Command:103}]
2022/01/11 23:02:08.470617 rf[1] heartbeat all send.
2022/01/11 23:02:08.470158 rf[0] election timeout start election
2022/01/11 23:02:08.470702 rf[1] start heartbeat. log:[{Term:0 Command:<nil>} {Term:1 Command:1} {Term:1 Command:104} {Term:1 Command:100} {Term:1 Command:103} {Term:1 Command:101}]
2022/01/11 23:02:08.470778 rf[1] heartbeat all send.
2022/01/11 23:02:08.470809 rf[0] term:2 role:2, 	sendRequestVote,	To rf[1] args:{Term:2 CandidateId:0 LastLogIndex:0 LastLogTerm:0}
2022/01/11 23:02:08.470891 rf[1] start heartbeat. log:[{Term:0 Command:<nil>} {Term:1 Command:1} {Term:1 Command:104} {Term:1 Command:100} {Term:1 Command:103} {Term:1 Command:101} {Term:1 Command:102}]
2022/01/11 23:02:08.470934 rf[1] heartbeat all send.
2022/01/11 23:02:08.471267 rf[1] term:1 role:3 Handle RequestVote, sendRf[0] term:2, term > turn to follower
2022/01/11 23:02:08.471402 rf[1] term:2 role:1 Handle RequestVote, sendRf[0] term:2, not vote
2022/01/11 23:02:08.471938 rf[2] term:1 role:1,	handle AppendEntries term == follower start handle,	From rf[1] term:1
2022/01/11 23:02:08.470885 rf[0] term:2 role:2, 	sendRequestVote,	To rf[2] args:{Term:2 CandidateId:0 LastLogIndex:0 LastLogTerm:0}
2022/01/11 23:02:08.472087 rf[2] term:1 role:1 follower handle AppendEntries append success, args:&{Term:1 LeaderId:1 PrevLogIndex:0 PrevLogTerm:0 Entries:[{Term:1 Command:1} {Term:1 Command:104} {Term:1 Command:100} {Term:1 Command:103} {Term:1 Command:101}] LeaderCommit:0}, log:[{Term:0 Command:<nil>} {Term:1 Command:1} {Term:1 Command:104} {Term:1 Command:100} {Term:1 Command:103} {Term:1 Command:101}]
2022/01/11 23:02:08.472199 rf[0] term:2 role:2,	handle AppendEntries term < follower return false and term to leader,	From rf[1] term:1
2022/01/11 23:02:08.472253 rf[2] term:1 role:1,	handle AppendEntries term == follower start handle,	From rf[1] term:1
2022/01/11 23:02:08.472458 rf[2] term:1 role:1 follower handle AppendEntries append success, args:&{Term:1 LeaderId:1 PrevLogIndex:0 PrevLogTerm:0 Entries:[{Term:1 Command:1} {Term:1 Command:104} {Term:1 Command:100} {Term:1 Command:103}] LeaderCommit:0}, log:[{Term:0 Command:<nil>} {Term:1 Command:1} {Term:1 Command:104} {Term:1 Command:100} {Term:1 Command:103} {Term:1 Command:101}]
2022/01/11 23:02:08.472623 rf[2] term:1 role:1 Handle RequestVote, sendRf[0] term:2, term > turn to follower
2022/01/11 23:02:08.472689 rf[2] term:2 role:1 Handle RequestVote, sendRf[0] term:2, not vote
2022/01/11 23:02:08.472732 rf[0] term:2 role:2,	handle AppendEntries term < follower return false and term to leader,	From rf[1] term:1
2022/01/11 23:02:08.472839 rf[0] term:2 role:2,	handle sendRequestVote reply,	From rf[2],	args:&{Term:2 CandidateId:0 LastLogIndex:0 LastLogTerm:0}	reply:&{Term:2 VoteGranted:false}
2022/01/11 23:02:08.472974 rf[0] term:2 role:2,	handle AppendEntries term < follower return false and term to leader,	From rf[1] term:1
2022/01/11 23:02:08.472997 rf[2] term:2 role:1,	handle AppendEntries term < follower return false and term to leader,	From rf[1] term:1
2022/01/11 23:02:08.473142 rf[2] term:2 role:1,	handle AppendEntries term < follower return false and term to leader,	From rf[1] term:1
2022/01/11 23:02:08.473182 rf[0] term:2 role:2,	handle sendRequestVote reply,	From rf[1],	args:&{Term:2 CandidateId:0 LastLogIndex:0 LastLogTerm:0}	reply:&{Term:2 VoteGranted:false}
2022/01/11 23:02:08.473402 rf[2] term:2 role:1,	handle AppendEntries term < follower return false and term to leader,	From rf[1] term:1
2022/01/11 23:02:08.473704 rf[0] term:2 role:2,	handle AppendEntries term < follower return false and term to leader,	From rf[1] term:1
2022/01/11 23:02:08.473728 rf[2] term:2 role:1,	handle AppendEntries term < follower return false and term to leader,	From rf[1] term:1
2022/01/11 23:02:08.473865 rf[0] term:2 role:2,	handle AppendEntries term < follower return false and term to leader,	From rf[1] term:1
2022/01/11 23:02:08.474018 rf[0] term:2 role:2,	handle AppendEntries term < follower return false and term to leader,	From rf[1] term:1
2022/01/11 23:02:08.695755 rf[2] election timeout start election
2022/01/11 23:02:08.695909 rf[2] term:3 role:2, 	sendRequestVote,	To rf[0] args:{Term:3 CandidateId:2 LastLogIndex:5 LastLogTerm:1}
2022/01/11 23:02:08.695960 rf[2] term:3 role:2, 	sendRequestVote,	To rf[1] args:{Term:3 CandidateId:2 LastLogIndex:5 LastLogTerm:1}
2022/01/11 23:02:08.696389 rf[1] term:2 role:1 Handle RequestVote, sendRf[2] term:3, term > turn to follower
2022/01/11 23:02:08.696490 rf[1] term:3 role:1 Handle RequestVote, sendRf[2] term:3, not vote
2022/01/11 23:02:08.696395 rf[0] term:2 role:2 Handle RequestVote, sendRf[2] term:3, term > turn to follower
2022/01/11 23:02:08.696628 rf[0] term:3 role:1 Handle RequestVote, sendRf[2] term:3, follower vote
2022/01/11 23:02:08.696757 rf[2] term:3 role:2,	handle sendRequestVote reply,	From rf[1],	args:&{Term:3 CandidateId:2 LastLogIndex:5 LastLogTerm:1}	reply:&{Term:3 VoteGranted:false}
2022/01/11 23:02:08.696911 rf[2] term:3 role:2,	handle sendRequestVote reply,	From rf[0],	args:&{Term:3 CandidateId:2 LastLogIndex:5 LastLogTerm:1}	reply:&{Term:3 VoteGranted:true}
2022/01/11 23:02:08.696983 rf[2] term:3 role:2,	handle sendRequestVote reply, Vote success, turn to leader, vote get:2 
2022/01/11 23:02:08.797670 rf[2] start heartbeat. log:[{Term:0 Command:<nil>} {Term:1 Command:1} {Term:1 Command:104} {Term:1 Command:100} {Term:1 Command:103} {Term:1 Command:101}]
2022/01/11 23:02:08.797806 rf[2] heartbeat all send.
2022/01/11 23:02:08.798221 rf[1] term:3 role:1,	handle AppendEntries term == follower start handle,	From rf[2] term:3
2022/01/11 23:02:08.798256 rf[0] term:3 role:1,	handle AppendEntries term == follower start handle,	From rf[2] term:3
2022/01/11 23:02:08.798392 rf[1] term:3 role:1 follower handle AppendEntries append success, args:&{Term:3 LeaderId:2 PrevLogIndex:5 PrevLogTerm:1 Entries:[] LeaderCommit:0}, log:[{Term:0 Command:<nil>} {Term:1 Command:1} {Term:1 Command:104} {Term:1 Command:100} {Term:1 Command:103} {Term:1 Command:101} {Term:1 Command:102}]
2022/01/11 23:02:08.798392 rf[0] term:3 role:1 follower handle AppendEntries, prevLogIndex too large, args:&{Term:3 LeaderId:2 PrevLogIndex:5 PrevLogTerm:1 Entries:[] LeaderCommit:0}, log:[{Term:0 Command:<nil>}], reply:&{Term:3 Success:false **FailedTerm:0 FirstIndexOfFailedTerm:0}**
2022/01/11 23:02:08.798628 rf[2] term:3 role:3 handle AppendEntries response:success update matchIndex[1] from:0 to:5
2022/01/11 23:02:08.798684 rf[2] term:3 role:3 FINISH handle AppendEntries response success from rf[1] matchIndex:**[0 5 0]**
2022/01/11 23:02:08.798751 rf[2] term:3 role:3 leader handle AppendEntries response:failed from rf[0] term:3, args prevIndex:5 entries_len:0 nextIndex:6 matchIndex:0, commitIndex:0
panic: runtime error: index out of range [-1]

goroutine 16 [running]:
ds/src/raft.(*Raft).genAppendEntriesParams(...)
	/home/coder/6.824/src/raft/raft.go:457
ds/src/raft.(*Raft).handleAppendEntriesResponse(0xc000160380, 0x0, 0xc000010fc0, 0xc00001ad00)
	/home/coder/6.824/src/raft/raft.go:435 +0xc1d
ds/src/raft.(*Raft).sendAppendEntries(0xc000160380, 0x0, 0xc000010fc0, 0xc00001ad00, 0x0)
	/home/coder/6.824/src/raft/raft.go:398 +0x18f
created by ds/src/raft.(*Raft).startHeartbeat
	/home/coder/6.824/src/raft/raft.go:473 +0x2da
exit status 2
FAIL	ds/src/raft	1.017s

## issue2022/01/11 23:59:38.621407 rf[4] term:1 role:1 Handle RequestVote, sendRf[0] term:1, follower vote
2022/01/11 23:59:38.621407 rf[4] term:1 role:1 Handle RequestVote, sendRf[0] term:1, follower vote
2022/01/11 23:59:38.621723 rf[4] election timeout start election

难道 reset election timeout 没有用?

## lab 2C 实现逻辑

raft should use persister to save its persistent state each time the state changes, ReadRaftState() SaveRaftState()

task: complete persist() and readPersist(), insert persist at the points where persistent state changes

curremtTerm, election timeout, receive larger term

voteFor, follower first vote,  turn to follower, candidate vote for self ...

log, leader `start`, follower append...



leader commit 1 term:1 command: 11 

follower 的 term 增加后  应该重置 voteFor



发现一个可能导致 2c 速度慢的原因, rf4 一直 election, 但是因为 log 不够新所以一直当不上 leader. 同时他不断的发起选举, 导致正常选举的 rf 不断的增加 term 并且重置



![image-20220120014306611](/Users/yujiacheng/Library/Application Support/typora-user-images/image-20220120014306611.png)
